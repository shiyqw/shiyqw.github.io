<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol.lst-kix_l1dacxbbexlp-2.start{counter-reset:lst-ctn-kix_l1dacxbbexlp-2 0}.lst-kix_919l49kvtqql-7>li:before{content:"" counter(lst-ctn-kix_919l49kvtqql-7,lower-latin) ". "}.lst-kix_l1dacxbbexlp-2>li:before{content:"(" counter(lst-ctn-kix_l1dacxbbexlp-2,lower-roman) ") "}.lst-kix_919l49kvtqql-4>li:before{content:"" counter(lst-ctn-kix_919l49kvtqql-4,lower-latin) ". "}.lst-kix_919l49kvtqql-8>li:before{content:"" counter(lst-ctn-kix_919l49kvtqql-8,lower-roman) ". "}.lst-kix_l1dacxbbexlp-3>li:before{content:"" counter(lst-ctn-kix_l1dacxbbexlp-3,decimal) ") "}.lst-kix_919l49kvtqql-2>li{counter-increment:lst-ctn-kix_919l49kvtqql-2}.lst-kix_fzvexukfi4jt-8>li:before{content:"" counter(lst-ctn-kix_fzvexukfi4jt-8,lower-roman) ". "}.lst-kix_919l49kvtqql-5>li:before{content:"" counter(lst-ctn-kix_919l49kvtqql-5,lower-roman) ". "}.lst-kix_l1dacxbbexlp-5>li:before{content:"" counter(lst-ctn-kix_l1dacxbbexlp-5,lower-roman) ") "}.lst-kix_l1dacxbbexlp-4>li:before{content:"" counter(lst-ctn-kix_l1dacxbbexlp-4,lower-latin) ") "}.lst-kix_919l49kvtqql-6>li:before{content:"" counter(lst-ctn-kix_919l49kvtqql-6,decimal) ". "}.lst-kix_l1dacxbbexlp-7>li:before{content:"" counter(lst-ctn-kix_l1dacxbbexlp-7,lower-latin) ". "}.lst-kix_w12e1j9334yv-0>li{counter-increment:lst-ctn-kix_w12e1j9334yv-0}ol.lst-kix_919l49kvtqql-7.start{counter-reset:lst-ctn-kix_919l49kvtqql-7 0}.lst-kix_l1dacxbbexlp-6>li:before{content:"" counter(lst-ctn-kix_l1dacxbbexlp-6,decimal) ". "}ol.lst-kix_w12e1j9334yv-3.start{counter-reset:lst-ctn-kix_w12e1j9334yv-3 0}ol.lst-kix_w12e1j9334yv-6.start{counter-reset:lst-ctn-kix_w12e1j9334yv-6 0}.lst-kix_919l49kvtqql-1>li{counter-increment:lst-ctn-kix_919l49kvtqql-1}.lst-kix_l1dacxbbexlp-8>li:before{content:"" counter(lst-ctn-kix_l1dacxbbexlp-8,lower-roman) ". "}ol.lst-kix_w12e1j9334yv-3{list-style-type:none}ol.lst-kix_w12e1j9334yv-4{list-style-type:none}ol.lst-kix_w12e1j9334yv-1{list-style-type:none}ol.lst-kix_w12e1j9334yv-2{list-style-type:none}ol.lst-kix_w12e1j9334yv-7{list-style-type:none}.lst-kix_fzvexukfi4jt-0>li{counter-increment:lst-ctn-kix_fzvexukfi4jt-0}ol.lst-kix_919l49kvtqql-4.start{counter-reset:lst-ctn-kix_919l49kvtqql-4 0}ol.lst-kix_w12e1j9334yv-8{list-style-type:none}ol.lst-kix_w12e1j9334yv-5{list-style-type:none}ol.lst-kix_w12e1j9334yv-6{list-style-type:none}ol.lst-kix_w12e1j9334yv-0.start{counter-reset:lst-ctn-kix_w12e1j9334yv-0 0}ol.lst-kix_fzvexukfi4jt-6.start{counter-reset:lst-ctn-kix_fzvexukfi4jt-6 0}ol.lst-kix_919l49kvtqql-2{list-style-type:none}ol.lst-kix_w12e1j9334yv-0{list-style-type:none}ol.lst-kix_919l49kvtqql-3{list-style-type:none}ol.lst-kix_919l49kvtqql-0{list-style-type:none}ol.lst-kix_919l49kvtqql-1{list-style-type:none}ol.lst-kix_919l49kvtqql-1.start{counter-reset:lst-ctn-kix_919l49kvtqql-1 0}ol.lst-kix_919l49kvtqql-6{list-style-type:none}ol.lst-kix_919l49kvtqql-7{list-style-type:none}ol.lst-kix_919l49kvtqql-4{list-style-type:none}.lst-kix_919l49kvtqql-1>li:before{content:"" counter(lst-ctn-kix_919l49kvtqql-1,lower-latin) ". "}ol.lst-kix_919l49kvtqql-5{list-style-type:none}ol.lst-kix_919l49kvtqql-8{list-style-type:none}ol.lst-kix_fzvexukfi4jt-0.start{counter-reset:lst-ctn-kix_fzvexukfi4jt-0 0}.lst-kix_919l49kvtqql-0>li:before{content:"" counter(lst-ctn-kix_919l49kvtqql-0,decimal) ". "}.lst-kix_919l49kvtqql-3>li:before{content:"" counter(lst-ctn-kix_919l49kvtqql-3,decimal) ". "}.lst-kix_l1dacxbbexlp-1>li:before{content:"(" counter(lst-ctn-kix_l1dacxbbexlp-1,lower-latin) ") "}ol.lst-kix_l1dacxbbexlp-7.start{counter-reset:lst-ctn-kix_l1dacxbbexlp-7 0}ol.lst-kix_fzvexukfi4jt-3.start{counter-reset:lst-ctn-kix_fzvexukfi4jt-3 0}.lst-kix_w12e1j9334yv-1>li{counter-increment:lst-ctn-kix_w12e1j9334yv-1}.lst-kix_l1dacxbbexlp-0>li:before{content:"(" counter(lst-ctn-kix_l1dacxbbexlp-0,decimal) ") "}.lst-kix_919l49kvtqql-2>li:before{content:"" counter(lst-ctn-kix_919l49kvtqql-2,lower-roman) ". "}ol.lst-kix_l1dacxbbexlp-1{list-style-type:none}.lst-kix_w12e1j9334yv-2>li{counter-increment:lst-ctn-kix_w12e1j9334yv-2}ol.lst-kix_l1dacxbbexlp-2{list-style-type:none}ol.lst-kix_919l49kvtqql-5.start{counter-reset:lst-ctn-kix_919l49kvtqql-5 0}ol.lst-kix_l1dacxbbexlp-3{list-style-type:none}ol.lst-kix_l1dacxbbexlp-4{list-style-type:none}ol.lst-kix_l1dacxbbexlp-5{list-style-type:none}ol.lst-kix_w12e1j9334yv-1.start{counter-reset:lst-ctn-kix_w12e1j9334yv-1 0}ol.lst-kix_l1dacxbbexlp-6{list-style-type:none}ol.lst-kix_w12e1j9334yv-8.start{counter-reset:lst-ctn-kix_w12e1j9334yv-8 0}.lst-kix_w12e1j9334yv-8>li{counter-increment:lst-ctn-kix_w12e1j9334yv-8}ol.lst-kix_l1dacxbbexlp-7{list-style-type:none}.lst-kix_l1dacxbbexlp-2>li{counter-increment:lst-ctn-kix_l1dacxbbexlp-2}ol.lst-kix_l1dacxbbexlp-8{list-style-type:none}ol.lst-kix_l1dacxbbexlp-0.start{counter-reset:lst-ctn-kix_l1dacxbbexlp-0 0}.lst-kix_l1dacxbbexlp-8>li{counter-increment:lst-ctn-kix_l1dacxbbexlp-8}.lst-kix_fzvexukfi4jt-1>li{counter-increment:lst-ctn-kix_fzvexukfi4jt-1}ol.lst-kix_fzvexukfi4jt-1.start{counter-reset:lst-ctn-kix_fzvexukfi4jt-1 0}ol.lst-kix_l1dacxbbexlp-0{list-style-type:none}.lst-kix_l1dacxbbexlp-7>li{counter-increment:lst-ctn-kix_l1dacxbbexlp-7}.lst-kix_l1dacxbbexlp-1>li{counter-increment:lst-ctn-kix_l1dacxbbexlp-1}.lst-kix_fzvexukfi4jt-7>li{counter-increment:lst-ctn-kix_fzvexukfi4jt-7}.lst-kix_919l49kvtqql-3>li{counter-increment:lst-ctn-kix_919l49kvtqql-3}.lst-kix_919l49kvtqql-6>li{counter-increment:lst-ctn-kix_919l49kvtqql-6}.lst-kix_919l49kvtqql-0>li{counter-increment:lst-ctn-kix_919l49kvtqql-0}ol.lst-kix_fzvexukfi4jt-2.start{counter-reset:lst-ctn-kix_fzvexukfi4jt-2 0}ol.lst-kix_919l49kvtqql-6.start{counter-reset:lst-ctn-kix_919l49kvtqql-6 0}.lst-kix_w12e1j9334yv-7>li:before{content:"" counter(lst-ctn-kix_w12e1j9334yv-7,lower-latin) ". "}ol.lst-kix_l1dacxbbexlp-5.start{counter-reset:lst-ctn-kix_l1dacxbbexlp-5 0}.lst-kix_w12e1j9334yv-6>li:before{content:"" counter(lst-ctn-kix_w12e1j9334yv-6,decimal) ". "}ol.lst-kix_fzvexukfi4jt-8.start{counter-reset:lst-ctn-kix_fzvexukfi4jt-8 0}ol.lst-kix_w12e1j9334yv-2.start{counter-reset:lst-ctn-kix_w12e1j9334yv-2 0}.lst-kix_w12e1j9334yv-8>li:before{content:"" counter(lst-ctn-kix_w12e1j9334yv-8,lower-roman) ". "}.lst-kix_w12e1j9334yv-0>li:before{content:"" counter(lst-ctn-kix_w12e1j9334yv-0,decimal) ". "}.lst-kix_w12e1j9334yv-5>li{counter-increment:lst-ctn-kix_w12e1j9334yv-5}.lst-kix_w12e1j9334yv-2>li:before{content:"" counter(lst-ctn-kix_w12e1j9334yv-2,lower-roman) ". "}.lst-kix_fzvexukfi4jt-4>li{counter-increment:lst-ctn-kix_fzvexukfi4jt-4}ol.lst-kix_919l49kvtqql-0.start{counter-reset:lst-ctn-kix_919l49kvtqql-0 0}.lst-kix_w12e1j9334yv-3>li:before{content:"" counter(lst-ctn-kix_w12e1j9334yv-3,decimal) ". "}.lst-kix_919l49kvtqql-7>li{counter-increment:lst-ctn-kix_919l49kvtqql-7}.lst-kix_l1dacxbbexlp-5>li{counter-increment:lst-ctn-kix_l1dacxbbexlp-5}.lst-kix_w12e1j9334yv-5>li:before{content:"" counter(lst-ctn-kix_w12e1j9334yv-5,lower-roman) ". "}.lst-kix_w12e1j9334yv-4>li:before{content:"" counter(lst-ctn-kix_w12e1j9334yv-4,lower-latin) ". "}.lst-kix_l1dacxbbexlp-4>li{counter-increment:lst-ctn-kix_l1dacxbbexlp-4}ol.lst-kix_fzvexukfi4jt-7.start{counter-reset:lst-ctn-kix_fzvexukfi4jt-7 0}.lst-kix_919l49kvtqql-8>li{counter-increment:lst-ctn-kix_919l49kvtqql-8}.lst-kix_w12e1j9334yv-6>li{counter-increment:lst-ctn-kix_w12e1j9334yv-6}ol.lst-kix_l1dacxbbexlp-6.start{counter-reset:lst-ctn-kix_l1dacxbbexlp-6 0}.lst-kix_w12e1j9334yv-1>li:before{content:"" counter(lst-ctn-kix_w12e1j9334yv-1,lower-latin) ". "}ol.lst-kix_l1dacxbbexlp-1.start{counter-reset:lst-ctn-kix_l1dacxbbexlp-1 0}.lst-kix_fzvexukfi4jt-6>li{counter-increment:lst-ctn-kix_fzvexukfi4jt-6}.lst-kix_fzvexukfi4jt-3>li{counter-increment:lst-ctn-kix_fzvexukfi4jt-3}ol.lst-kix_919l49kvtqql-8.start{counter-reset:lst-ctn-kix_919l49kvtqql-8 0}ol.lst-kix_w12e1j9334yv-4.start{counter-reset:lst-ctn-kix_w12e1j9334yv-4 0}ol.lst-kix_l1dacxbbexlp-4.start{counter-reset:lst-ctn-kix_l1dacxbbexlp-4 0}.lst-kix_w12e1j9334yv-4>li{counter-increment:lst-ctn-kix_w12e1j9334yv-4}.lst-kix_w12e1j9334yv-7>li{counter-increment:lst-ctn-kix_w12e1j9334yv-7}ol.lst-kix_w12e1j9334yv-7.start{counter-reset:lst-ctn-kix_w12e1j9334yv-7 0}ol.lst-kix_fzvexukfi4jt-5.start{counter-reset:lst-ctn-kix_fzvexukfi4jt-5 0}.lst-kix_919l49kvtqql-5>li{counter-increment:lst-ctn-kix_919l49kvtqql-5}.lst-kix_w12e1j9334yv-3>li{counter-increment:lst-ctn-kix_w12e1j9334yv-3}.lst-kix_919l49kvtqql-4>li{counter-increment:lst-ctn-kix_919l49kvtqql-4}ol.lst-kix_919l49kvtqql-2.start{counter-reset:lst-ctn-kix_919l49kvtqql-2 0}ol.lst-kix_l1dacxbbexlp-3.start{counter-reset:lst-ctn-kix_l1dacxbbexlp-3 0}ol.lst-kix_fzvexukfi4jt-4.start{counter-reset:lst-ctn-kix_fzvexukfi4jt-4 0}ol.lst-kix_fzvexukfi4jt-8{list-style-type:none}ol.lst-kix_fzvexukfi4jt-7{list-style-type:none}.lst-kix_l1dacxbbexlp-6>li{counter-increment:lst-ctn-kix_l1dacxbbexlp-6}ol.lst-kix_l1dacxbbexlp-8.start{counter-reset:lst-ctn-kix_l1dacxbbexlp-8 0}.lst-kix_fzvexukfi4jt-0>li:before{content:"" counter(lst-ctn-kix_fzvexukfi4jt-0,decimal) ". "}.lst-kix_l1dacxbbexlp-3>li{counter-increment:lst-ctn-kix_l1dacxbbexlp-3}.lst-kix_fzvexukfi4jt-1>li:before{content:"" counter(lst-ctn-kix_fzvexukfi4jt-1,lower-latin) ". "}.lst-kix_l1dacxbbexlp-0>li{counter-increment:lst-ctn-kix_l1dacxbbexlp-0}.lst-kix_fzvexukfi4jt-2>li{counter-increment:lst-ctn-kix_fzvexukfi4jt-2}.lst-kix_fzvexukfi4jt-3>li:before{content:"" counter(lst-ctn-kix_fzvexukfi4jt-3,decimal) ". "}.lst-kix_fzvexukfi4jt-5>li{counter-increment:lst-ctn-kix_fzvexukfi4jt-5}ol.lst-kix_w12e1j9334yv-5.start{counter-reset:lst-ctn-kix_w12e1j9334yv-5 0}.lst-kix_fzvexukfi4jt-2>li:before{content:"" counter(lst-ctn-kix_fzvexukfi4jt-2,lower-roman) ". "}.lst-kix_fzvexukfi4jt-4>li:before{content:"" counter(lst-ctn-kix_fzvexukfi4jt-4,lower-latin) ". "}.lst-kix_fzvexukfi4jt-8>li{counter-increment:lst-ctn-kix_fzvexukfi4jt-8}ol.lst-kix_fzvexukfi4jt-2{list-style-type:none}.lst-kix_fzvexukfi4jt-7>li:before{content:"" counter(lst-ctn-kix_fzvexukfi4jt-7,lower-latin) ". "}ol.lst-kix_fzvexukfi4jt-1{list-style-type:none}ol.lst-kix_919l49kvtqql-3.start{counter-reset:lst-ctn-kix_919l49kvtqql-3 0}ol.lst-kix_fzvexukfi4jt-0{list-style-type:none}.lst-kix_fzvexukfi4jt-6>li:before{content:"" counter(lst-ctn-kix_fzvexukfi4jt-6,decimal) ". "}.lst-kix_fzvexukfi4jt-5>li:before{content:"" counter(lst-ctn-kix_fzvexukfi4jt-5,lower-roman) ". "}ol.lst-kix_fzvexukfi4jt-6{list-style-type:none}ol.lst-kix_fzvexukfi4jt-5{list-style-type:none}ol.lst-kix_fzvexukfi4jt-4{list-style-type:none}ol.lst-kix_fzvexukfi4jt-3{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c8{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:18pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Arial";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c13{color:#000000;text-decoration:none;vertical-align:baseline;font-size:18pt;font-family:"Arial";font-style:normal}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c7{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c14{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:right}.c15{background-color:#ffffff;max-width:451.4pt;padding:72pt 72pt 72pt 72pt}.c10{font-size:10pt;font-style:italic}.c4{margin-left:36pt;padding-left:0pt}.c0{padding:0;margin:0}.c9{margin-left:72pt;padding-left:0pt}.c12{font-weight:700}.c6{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c15"><p class="c3"><span class="c12 c13">Final Writeup</span></p><p class="c3"><span class="c11">OpenHash: Lock-free Concurrent Resizable HashMap</span></p><p class="c14"><span class="c5">Yangqingwei Shi</span></p><p class="c14"><span class="c5">Yiqun Ouyang</span></p><p class="c6 c14"><span class="c5"></span></p><p class="c1"><span class="c8">SUMMARY</span></p><p class="c1"><span class="c2">We implemented a lock-free concurrent resizable HashMap in C++, and we would like to call it OpenHash. It truly supports multiple concurrent writers, has a rich set of APIs and automatically does non-blocking live data migration on high capacity. As the results showed, it outperforms fine-grained HashMap greatly, has a similar performance on read intensive workloads with CuckooHash, which was the former 15618 projects, and a higher performance on write intensive workloads.</span></p><p class="c1 c6"><span class="c8"></span></p><p class="c1"><span class="c12">BACKGROUND.</span></p><p class="c1"><span class="c2">HashMap is a really widely used data structures almost in every programming language. It has O(1) lookup, insert, modify and delete operations. Different programming languages have different interfaces for HashMap, such as unordered_map in C++ STL, HashMap in Java and dict in Python.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">Thread safety is an important property in HashMap implementation. Different programming languages have different support of thread safety in HashMap implementation. C++ uses std::unordered_map as its HashMap. As described in STL documentation, STL containers are designed so that you are guaranteed to be able to have multiple threads reading at the same time but just one thread writing at the same time. Having multiple threads writing is not allowed so that user should do synchronization in caller codes. Java&rsquo;s HashMap has the same thread safety as C++ while Java also provide another implementation called ConcurrentHashMap which supports multiple reads. The problem of Java&rsquo;s HashMap is the performance. Since it is not a lock-free implementation, the performance will be influenced by large amount of blockings. </span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">In this project, we are offering truly concurrent implementation which fully supports multiple writers, and lock-free solution rather than locking one.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 262.67px;"><img alt="" src="images/image1.png" style="width: 601.70px; height: 262.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c2">Figure 1: Chaining address and open address</span></p><p class="c1"><span>One of the design consideration</span><span class="c10">&nbsp;[Figure 1]</span><span class="c2">&nbsp;is the chaining address or open address when Hash collision happens. The chaining solution allows the bucket to store the head of a linked list and put all the colliding keys into the link, where as the open address solution just try to find a bucket nearby to reside the key pair, so one bucket will still hold only one key-value pair. The major disadvantage of the chaining solution is that the cache locality is poor, as well as extra space needed. So in this project we adopts open address solution.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">Also, resizability is a basic feature for a HashMap because we should always hold enough buckets but allocating them all at the beginning is not possible. Resizability under concurrent lock-free HashMap is not trivial, actually it is the biggest challenge that we were solving in this project. The proposed method will be stated in the following chapters.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c12">APPROACH</span></p><p class="c1"><span class="c8">Data Structure Overview:</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 210.67px;"><img alt="" src="images/image5.png" style="width: 601.70px; height: 210.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c2">Figure 2: main data structure overview</span></p><p class="c1"><span>The main data structure</span><span class="c10">[Figure 2] </span><span class="c2">is an array, where the first slot is the header and a pointer. A HashMap instance has pointer to the current table, and when migration is happening, the header of the current table points to the head of the new table, which has exactly the same structure but definitely bigger in size. When migration ends, the &ldquo;current table&rdquo; pointer points to the new one and just delete the old one.</span></p><p class="c1"><span class="c2">The second slot has the pointer to all the metadata, which is now the hashes of all the existing slots for lookup speed up. The remaining slots are key-value pairs. Notice that the migration will not block the get or put operations.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c8">Three layer of major APIs:</span></p><p class="c1"><span class="c2">OpenHash offers rich set of APIs for users, that is the first layer of APIs that are exposed explicitly. There are Put, PutIfAbsent, Remove, Remove when the Value matches, Replace, Replace when the Value matches, these are all implemented by put_if_match API, which means &ldquo;if the value found expected value, then do put&rdquo;; Get is simply implemented by get_slot. put_if_match and get_slot are second layer APIs where actual put/get operations are executed.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">The resize events happens when the capacity is high. A resize event be triggered when putting key-value pairs. True migration work is executed in copy_slot where a slot is copied from old table to the new one.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">The second and third layer of APIs could be called directly by the user but they are the core part for the correctness.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 497.49px; height: 297.50px;"><img alt="" src="images/image8.png" style="width: 497.49px; height: 297.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c2">Figure 3: three layers of APIs</span></p><p class="c3 c6"><span class="c2"></span></p><p class="c1"><span class="c8">Correctness Of Migration:</span></p><p class="c1"><span class="c2">As is stated in the previous sections, the correctness of migration under concurrent lock-free hashmap is the core challenge. That&rsquo;s because:</span></p><ol class="c0 lst-kix_w12e1j9334yv-0 start" start="1"><li class="c1 c4"><span class="c2">The execution should be non-blocking, the put and get API should still be working when migration is happening, even on the same key.</span></li><li class="c1 c4"><span class="c2">Shouldn&rsquo;t lose updates, or even have more obvious mistakes. For example, in a slot where the old value is written to the new table, and the upcoming updates should happen in new table rather than just stopping at updating the old value in the old table.</span></li><li class="c1 c4"><span class="c2">There is no locks or transactions available, so a sequence of operations which should be executed in an atomic manner couldn&rsquo;t be executed in this desired way, so intermediate states will be exposed to concurrent threads. This adds much more corner cases that should be handled correctly or even elegantly, which made the solution more difficult.</span></li></ol><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">So we&rsquo;ve come up with a solution which follows those pricinples:</span></p><ol class="c0 lst-kix_919l49kvtqql-0 start" start="1"><li class="c1 c4"><span class="c2">Because there are no transactions available, we decomposed the sequence of operations to multiple CAS actions, and view the one who wins the first CAS operation as winner, this thread shall complete all the following operations and &ldquo;commit&rdquo;, all the competitors will &ldquo;abort&rdquo;</span></li><li class="c1 c4"><span class="c2">Even with the principle 1, there are still many partial updates exposed to other threads. Actually this is race, so in most cases the threads who saw unexpected partial results will just start from the beginning and retry.</span></li><li class="c1 c4"><span class="c2">TOMB marker used for deleted slots, PRIME marker used for migrating slots. TOMB makes remove actions simple; PRIME make all threads aware that the slot is under migration, so proper actions could be done.</span></li></ol><p class="c1 c6"><span class="c2"></span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 338.67px;"><img alt="" src="images/image7.png" style="width: 601.70px; height: 338.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c2">Figure 4: The flow of put_if_match method and Migrate</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span>There are two examples </span><span class="c10">[Figure 4]</span><span class="c2">&nbsp;that follows those principles, which are both core part of the implementation. In the put_if_match() implementation, the first step is to iterate through the neighbor of the starting index, to see if there are free slots or matching key. If a free slot is found it will CAS this key, so later threads will not get this slot; after the key is claimed, the thread checks the value and hopefully CAS the value. So CAS first happen on keys and then values, when this order is maintained, we don&rsquo;t need transactions to ensure the correctness.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">But the iteration may fail because it has reprobed to a place too far away or has detected that the table is under migration. In this case, it tries to resize, migrate the current value in the current table to new table and then execute the put.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">Corner cases could happen when checking the value. Because there are many parameters sent in the put_if_match function, we should check if the value satisfied certain conditions, so that we can return early either there is no need to put the value or the value shouldn&rsquo;t be modified.</span></p><p class="c1"><span class="c2">&nbsp;</span></p><p class="c1"><span class="c2">When value is PRIME, which means the migration is just happening, the thread will try resize (which will surely return early and do nothing), migrate and put the value in the new table.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">When migration happens, the thread first try to modify the value as PRIME, and then put the current value into new table by put_if_match, finally mark the value in old table as &ldquo;migration completed&rdquo;</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">There are some corner cases, and most important ones are encountering PRIME when putting or getting. In these cases, threads should help migration, drop all completed work in the old table and do it from the beginning in the new table.</span></p><p class="c1"><span class="c8">Optimizations and Details:</span></p><p class="c1"><span class="c2">When working through the project, optimizations, no matter small ones or big ones, are happening.</span></p><ol class="c0 lst-kix_fzvexukfi4jt-0 start" start="1"><li class="c1 c4"><span class="c2">Help_copy: The migration of the table should be completed in a parallel manner, every thread executes a non-overlapping portion of the migration. In the following example, suppose &ldquo;i&rdquo; is the index of currently completed migration, and whatever i will be, this thread will migrate i to i+3</span></li></ol><ol class="c0 lst-kix_fzvexukfi4jt-1 start" start="1"><li class="c7 c9"><span class="c5">while(CAS(&amp;completed_copy,i,i+4)!= i){</span></li><li class="c7 c9"><span class="c5">&nbsp; &nbsp; &nbsp; read i again</span></li><li class="c7 c9"><span class="c5">}</span></li><li class="c7 c9"><span class="c5">migrate slots from i to i+3 </span></li></ol><ol class="c0 lst-kix_fzvexukfi4jt-0" start="2"><li class="c7 c4"><span class="c2">Do hashes comparison before Objects Comparison. Because we place no restriction to the key-value type, the key comparison could be expensive; and it the linear probing, key comparing is necessary. So the hashes of all indices are stored into an array and hash comparison is executed first to quickly sort out impossible matches and avoid expensive object comparison.</span></li><li class="c7 c4"><span class="c2">Use pointers to minimize GC. When migrating the key-value pairs, one possible resulting situation would be destroying the objects in the old table and creating a new one (the same one) on the new table. The better way is to use pointer as keys and values so that the objects could be reused and only pointers are changing, no GC overhead.</span></li><li class="c7 c4"><span class="c2">Early cut-offs and miscellaneous.Something like putting TOMB on keys to inform others migration is happening; no need to put if old value equals to new value.</span></li></ol><p class="c7 c6"><span class="c2"></span></p><p class="c7"><span class="c8">Probing: Why not using non-linear probing like Hopscotch/Cuckoo/LeapFrog?</span></p><p class="c7"><span class="c2">With linear hashing, the performance degradation is doomed on higher load; with smarter probing strategies, lookups will be speeded up but extra data structure is needed. This requires extra space for every slot, as well as extra dependencies, and it will have heavier contentions and possibly some slow down.</span></p><p class="c7 c6"><span class="c2"></span></p><p class="c7"><span class="c2">But the most important reason should be that the implementation complexity. We should have consistent data and metadata without locks or transactions, and the metadata is related one to another, modifying them correctly when race could happen is just messy. What&rsquo;s more it is a non-blocking data structure so we cannot consider the migration as &nbsp;totally ordered or well-structured, any slots that are visited needed to be migrated right away. </span></p><p class="c7 c6"><span class="c2"></span></p><p class="c7"><span class="c2">So, we didn&rsquo;t try non-linear probing where extra metadata is needed. But we did try some variation of linear probing, and the results will be shown in the experiment part.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c8">RESULTS</span></p><p class="c1 c6"><span class="c8"></span></p><p class="c1"><span class="c2">Environment</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">For evaluation, we use two Intel Xeon E5-2620 v3 processors. In specific, we use the platform of last year&rsquo;s project ParaCuckooHash. We use two of their implementations as baseline, the fine-grained lock hashmap and the optimized Cuckoo HashMap (this is the hashmap of highest performance last year). To compare the performance, we use 10K operations with different intensity. We increase the number of threads from 1 thread to 45 threads. To achieve fairness, for all data structures, we init their size with 1024 slots. </span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">Experiment 1 Correctness Test</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span>We have two correctness test. For the first test, we run a bunch of concurrent puts, then a bunch of concurrent a bunch of concurrent removes. We found that the data-structure is empty at the end, so the remove function works. For the second test, we run a bunch of concurrent puts and join all threads and then a bunch of concurrent gets. We found each element we put in the hashmap can be get from gets. So the put/get function works. </span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">Experiment 2 Comparison between different structures</span></p><p class="c1"><span class="c2">Results on Read/Write Intensive Hash Functions are shown in the following pictures.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 437.31px; height: 327.50px;"><img alt="wi.png" src="images/image3.png" style="width: 437.31px; height: 327.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2">Figure 5: Relation of threads number and time consumption for Read-Intensive Data (90%Read)</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 403.68px; height: 302.50px;"><img alt="ri.png" src="images/image2.png" style="width: 403.68px; height: 302.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2">Figure 6: Relation of threads number and time consumption for Write-Intensive Data (70% Write)</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 404.62px; height: 304.50px;"><img alt="ri2.png" src="images/image4.png" style="width: 404.62px; height: 304.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2">Figure 7: Relation of threads number and time consumption for Write-Intensive Data (70% Write) (Zoom-In)</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">From the three figures above we can get the following conclusion:</span></p><ol class="c0 lst-kix_l1dacxbbexlp-0 start" start="1"><li class="c1 c4"><span class="c2">In both read intensive and write intensive, OpenHash and OptimizedCuckoo performs far better than traditional fine-grained lock hashmap. The speedup is more than 10X. </span></li><li class="c1 c4"><span class="c2">For OpenHash and OptimizedCuckoo, the best performace happens near the thread number is 5. Before threads number comes to 5, increasing threads number can enhance the total performance by parallel the computation, while after threads number reaches 5, the total performance decrease because of high contentions. This conclusion is consistent with last year&rsquo;s project.</span></li><li class="c1 c4"><span class="c2">In read-intensive data, OptimizedCuckoo performs better at higher number of threads but the difference between OptimizedCuckoo and OpenHash is not significant. In write-intensive data, OpenHash outperforms OptimizedCuckoo much significantly. </span></li><li class="c1 c4"><span class="c2">The performance of OpenHash varies little while the read intensity changes. However, OptimizedCuckoo has significant performance increase while read intensity increases. We believe there is some great optimizations specific to read-intensive data in OptimizedCuckoo. </span></li></ol><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">Experiment 2 Comparison between different version of OpenHash.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">We tried several different modification to our OpenHash and have 4 different versions. They are:</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">Typical Linear: The classical linear hash model. If reprobe is necessary, the iterator will simply go one step into its next slot. </span></p><p class="c1"><span class="c2">4-Space Slot: Each slot have 4 spaces that can hold 4 pairs of key and value.</span></p><p class="c1"><span class="c2">Double-Jump: If reprobe is necessary, the iterator will jump back-and-forth in both directions, such as +1, -2, +3, -4, &hellip;., which can fully use the space in both direction</span></p><p class="c1"><span class="c2">Smaller Reprobe Limit: In our implementation, we set the reprobing limit to be the 50% of the number of slots. In this version we set it 25%. Although smaller reprobe limit will reduce the space efficiency, but resizing in the early stage will make key hit more easily. </span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1 c6"><span class="c2"></span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 457.50px; height: 342.75px;"><img alt="4.png" src="images/image6.png" style="width: 457.50px; height: 342.75px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2">Figure 8: &nbsp;Relation of threads number and time consumption for different version of OpenHash.</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c2">From the result, we can notice the the four versions have almost the same performance. The original simple linear probing method performs a little bit better than the other three. However, we believe such performance enhance is trivial. </span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1 c6"><span class="c8"></span></p><p class="c1 c6"><span class="c8"></span></p><p class="c1"><span class="c8">References:</span></p><p class="c1"><span class="c2">All web pages and papers that may contribute to the project are listed here</span></p><p class="c1"><span class="c2">[1]ParaCuckooHash: http://www.andrew.cmu.edu/user/bqiu/</span></p><p class="c1"><span>[2]A resizable HashMap: </span><span class="c2">http://preshing.com/20160222/a-resizable-concurrent-map/</span></p><p class="c1"><span class="c2">[3]Junction: https://github.com/preshing/junction</span></p><p class="c1"><span class="c2">[4]Leap Frog Probing: http://preshing.com/20160314/leapfrog-probing/</span></p><p class="c1"><span class="c2">[5]New concurrent Map for C++: http://preshing.com/20160201/new-concurrent-hash-maps-for-cpp/</span></p><p class="c1"><span class="c2">[6]High scale lib: https://github.com/stephenc/high-scale-lib</span></p><p class="c1"><span>[7]Cuckoo Hashing: https://en.wikipedia.org/wiki/Cuckoo_hashing</span></p><p class="c1"><span class="c2">[8]Dechev D, Pirkelbauer P, Stroustrup B. Lock-free dynamically resizable arrays[C]//International Conference On Principles Of Distributed Systems. Springer Berlin Heidelberg, 2006: 142-156.</span></p><p class="c1"><span class="c2">[9]Michael M M. Hazard pointers: Safe memory reclamation for lock-free objects[J]. IEEE Transactions on Parallel and Distributed Systems, 2004, 15(6): 491-504.</span></p><p class="c1"><span class="c2">[10] Hopscotch hashing: https://en.wikipedia.org/wiki/Hopscotch_hashing</span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1 c6"><span class="c2"></span></p><p class="c1"><span class="c8">Work Distribution:</span></p><p class="c1"><span class="c8">Equal work was performed by both project members.</span></p></body></html>